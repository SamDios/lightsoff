#!/bin/bash
#
# Überwacht das LAN auf aktive Rechner und
# fährt den Server runter, wenn niemand mehr
# im LAN aktiv ist
#

### BEGIN INIT INFO
# Provides:       lightsoff
# Required-Start: $network $syslog $remote_fs
# Required-Stop:  $network $syslog $remote_fs
# Default-Start:  3 5
# Default-Stop:   0 1 2 6
# Short-Description: stopps the server if there is no active host in the lan
# Description:    stopps the server if there is no active host in the lan
### END INIT INFO

# multilanguage support via get
TEXTDOMAINDIR=/usr/local/share/locale/
TEXTDOMAIN=lightsoff
INTERVAL=360
TIME2CHECK="0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"
SERVERHOST=`grep -v ^# <<!
192.168.178.100
#192.168.178.110
!`
SERVERMACS=`grep -v ^# <<!
00:08:9B:E8:92:61
!`
SERVERUSER="admin"
SERVERPASS="1q2w3e4R!"
SERVERSCMD="sshpass -p $SERVERPASS ssh -f $SERVERUSER@$SERVERHOST /bin/echo mem > /sys/power/state 2>/dev/null"
SERVERWCMD="wakeonlan"
PING="ping -c 2"

# List of hosts
HOSTS=`grep -v ^# <<!
192.168.178.200
192.168.178.102
192.168.178.103
192.168.178.107
!`
# Debugging: 1 == an, '' == aus
DEBUG="1"
TIMESTAMP=`date -u +%Y-%m-%d-%H.%M.%S`
# Logging: path to logfile, leave empty == no logging
# LOGFILE="/var/log/lightsoff.log"
LOGFILEA="/var/log/lightsoff.log"
LOGFILE=""

# Redirect echo and log messages
exec > >(tee -a ${LOGFILEA} )
exec 2> >(tee -a ${LOGFILEA} >&2)

[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: ###############################################################"
[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Lightsoff debug log ..."
[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: Lightsoff debug log, printing variables ..."

# Checking root privileges
if [ ${UID} -gt 0 ]
	then
		[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: No root privileges, exiting."
		[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: No root privileges, exiting."
		exit 1
	else
		[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Root privileges, continuing."
		[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: Root privileges, continuing."
fi

ACTIVE=false
SACTIVE=false

# Lockfile with process ID (PID)
BASENAME=`basename $0`
LOCKFILE="/var/run/${BASENAME}.pid"

# Check for online hosts
checkhosts()
{
[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Searching for online hosts ($HOSTS) ..."
ACTIVE=false
for ADDR in ${HOSTS}
do
  ${PING} ${ADDR} > /dev/null
  if [ $? -eq 0 ]
   then
    [ ${DEBUG} ] && echo $"$0: $TIMESTAMP: "${ADDR}" is active!"
    ACTIVE=true
    continue
   else
    [ ${DEBUG} ] && echo $"$0: $TIMESTAMP: "${ADDR}" is not active!"
   fi
done

# ist ACTIVE noch 0, sind alle Rechner aus?
if [ "${ACTIVE}" = "false" ]
then
    # schaltet Rechner ab, falls keine lokalen/SSH-Nutzer da sind
    [ ${DEBUG} ] && echo $"$0: $TIMESTAMP: No hosts active in the LAN."
    [ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: No hosts active in the LAN."
    lightsoff
else
    [ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Some PCs are active, checking server."
	[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Some PCs are active, checking server."
	checkserver
	if [ "${SACTIVE}" = "false" ]
		then
		[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Server is offline, waking up server."
		[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Server is offline, waking up server."
		for MACADDR in ${SERVERMACS}
			do
				[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Running command $SERVERWCMD $MACADDR ..."
				[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Running command $SERVERWCMD $MACADDR ..."
				${SERVERWCMD} ${MACADDR}
			done
		
    else
    [ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Server is already online, doing nothing."
	[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Server is already online, doing nothing."
	fi
fi

} 

#####
# Check if server is online
checkserver()
{
	SACTIVE=false
	for ADDR in ${SERVERHOST}
		do
			${PING} ${ADDR} > /dev/null
			if [ $? -eq 0 ]
				then
					[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Server ("${ADDR}") is active!"
					SACTIVE=true
					continue
				else
					[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Server ("${ADDR}") is not active!"
				fi
		done
	# return ${SACTIVE}
}

#####
# Switches off the server, does nothing if it is offline
lightsoff()
{
	checkserver
    if [ "${SACTIVE}" = "true" ]
		then
		# schaltet Rechner ab, falls keine lokalen/SSH-Nutzer da sind
		[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Disabling server."
		[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Disabling server."
		[ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Running command $SERVERSCMD ..."
		[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Running command $SERVERSCMD ..."
		[ ${LOGFILE} ] && logger -f $LOGFILE "$TIMESTAMP: Running command $SERVERSCMD ..."
		$SERVERSCMD
    else
    [ ${DEBUG} ] && echo $"$0: $TIMESTAMP: Server is already offline, doing nothing."
	[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Server is already offline, doing nothing."
	fi
	
}

#####
# Check for local, ssh and screen session users
localUsers()
{
    USERCOUNT=`w -h | sed '/^\s*$/d' | wc -l`
	USERNAMES=`who | awk '{ print $1 }' | sort | uniq`
    [ $DEBUG ] && echo $"$0: $TIMESTAMP: Local users online: $USERCOUNT ($USERNAMES)"
	[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Local users online: $USERCOUNT ($USERNAMES)"
    return ${COUNT}
}

#####
# Main script
case "$1" in 
    start)
        echo -ne $"Starting $0 "
	$0 run & 
	while [ ! -e ${LOCKFILE} ]
	do
	  echo -ne "."
	  sleep 2
	done
	echo $"(PID: "`cat ${LOCKFILE}`")."
	exit 
	;;
    stop)
        if [ -e ${LOCKFILE} ]
	then
	  CPID=`cat ${LOCKFILE}`
	  echo -ne $"Stopping $0 with PID $CPID "
	  # beenden mit SIGTERM,
	  # warte bis PID-File entfernt ist
	  while [ -e ${LOCKFILE} ]
	  do
	     echo -ne "."
	     kill ${CPID}
	     sleep 2
	  done
	  echo $"[done]"
    
	else
	  echo $"$0 is not running."
	  exit
	fi	  
	;;
    restart)
        $0 stop ; $0 start
	;;
    run)
	if [ -e ${LOCKFILE} ]
	then 
	    CPID=`cat ${LOCKFILE}`
		[ $DEBUG ] && echo $"$0: $TIMESTAMP: Program is already running. (PID: ${CPID})"
	    [ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Program is already running. (PID: ${CPID})"
	    exit -1
	else
            # PID File samt PID speichern wird via trap am Programm-Ende wieder entsorgt
	    echo $$ > ${LOCKFILE}
	    trap "rm -f ${LOCKFILE}; exit" INT TERM EXIT
	fi
	
        # foreground
	while true
	do
	    for hour in ${TIME2CHECK}
	    do
		if [ `date +%H` -eq ${hour} ]
		then
		    [ $DEBUG ] && echo $"$0: $TIMESTAMP: Hour criterium ($hour) met, running checks ..."
		    [ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Hour criterium ($hour) met, running checks ..."
	            # falls wer angemeldet ist, wird nichts weiter getan
		    localUsers
		    if [ $? -eq 0 ]
		    then checkhosts 
		    else 
			checkhosts
			# [ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $" $? $TIMESTAMP: Local users logged in, stopping script for $INTERVAL seconds!"
		    fi
		else
		    # [ $DEBUG ] && echo $"$0: doing nothing ... ($hour) ..."
		    # [ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"doing nothing ... ($hour) ..."
		    continue
		fi
	    done
	    sleep $INTERVAL
	done	
	;;
    status)
	# Statusabfrage
	# added by nico
	if [ -e ${LOCKFILE} ]
	then
	    CPID=$(cat ${LOCKFILE})
	    while [ -e ${LOCKFILE} ]
	    do
		[ $DEBUG ] && echo $"$0: $TIMESTAMP: Is running with PID $CPID"
		[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Is running with PID $CPID"
	    done
	else
	    [ $DEBUG ] && echo $"$0: $TIMESTAMP: Is not running."
		[ ${LOGFILE} ] && logger -f $LOGFILE -t $0 $"$0: $TIMESTAMP: Is not running."
	fi
	exit 
	;;
    *)
	echo $"usage: $0 start|stop|restart|run|status"
	echo $"options:"
	echo $"  start: runs program in background"
	echo $"   stop: stops background program"
	echo $"restart: restart a already running instance"
	echo $"    run: run program in foreground, stopps with Strg-C"
	echo $" status: checks whether program is running"
	exit
	;;
esac
